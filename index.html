<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Chess Board with Pointer Events</title>
  <style>
    /* ===== 전체 레이아웃 ===== */
    body {
      margin: 0;
      padding: 0;
      background-color: #fafafa;
      font-family: Arial, sans-serif;
    }
    .chess-container {
      max-width: 800px; 
      width: 100%;
      margin: 0 auto;
      padding: 20px;
      box-sizing: border-box;
      background-color: #ffffff;
      min-height: 100vh;
    }
    .board-wrapper {
      width: 100%;
      max-width: 480px;
      margin: 0 auto;
    }

    /* ===== 체스 보드 (8x8) ===== */
    .chess-board {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      grid-template-rows: repeat(8, 1fr);
      border: 2px solid #333;
      aspect-ratio: 1 / 1; /* 가로/세로 비율 1:1 */
    }
    .square {
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative; /* 기물이 상대배치(absolute)로 들어올 수 있음 */
    }
    .dark {
      background-color: #769656;
    }
    .light {
      background-color: #eeeed2;
    }

    /* ===== 기물 스타일 ===== */
    .piece {
      width: 90%;
      height: 90%;
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      position: relative;
      z-index: 1;
      margin: auto;
    }
    /* 각 기물별 배경 위치 */
    .piece.black.king { background-image: url('./images/pieces/bk.svg'); }
    .piece.black.queen { background-image: url('./images/pieces/bq.svg'); }
    .piece.black.rook { background-image: url('./images/pieces/br.svg'); }
    .piece.black.bishop { background-image: url('./images/pieces/bb.svg'); }
    .piece.black.knight { background-image: url('./images/pieces/bn.svg'); }
    .piece.black.pawn { background-image: url('./images/pieces/bp.svg'); }
    .piece.white.king { background-image: url('./images/pieces/wk.svg'); }
    .piece.white.queen { background-image: url('./images/pieces/wq.svg'); }
    .piece.white.rook { background-image: url('./images/pieces/wr.svg'); }
    .piece.white.bishop { background-image: url('./images/pieces/wb.svg'); }
    .piece.white.knight { background-image: url('./images/pieces/wn.svg'); }
    .piece.white.pawn { background-image: url('./images/pieces/wp.svg'); }
    /* 드래그 중 상태를 표시할 수도 있음 */
    .dragging {
      opacity: 0.8;
      cursor: grabbing;
    }
    /* 선택된 기물 표시 */
    .selected {
      transform: translateY(-10px); /* 위로 살짝 떠오르는 효과 */
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3); /* 그림자 효과 */
      transition: all 0.2s ease; /* 부드러운 애니메이션 */
      z-index: 2; /* 다른 기물들 위에 표시 */
    }
    /* 기물 제거 애니메이션 */
    @keyframes breakPiece {
      0% {
        transform: scale(1) rotate(0deg);
        opacity: 1;
        clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%);
      }
      50% {
        transform: scale(0.8) rotate(90deg);
        opacity: 0.8;
        clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%);
      }
      100% {
        transform: scale(0.8) rotate(180deg);
        opacity: 0;
        clip-path: polygon(0 0, 50% 0, 50% 100%, 0 100%);
      }
    }

    @keyframes breakPieceRight {
      0% {
        transform: scale(1) rotate(0deg);
        opacity: 1;
        clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%);
      }
      50% {
        transform: scale(0.8) rotate(90deg);
        opacity: 0.8;
        clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%);
      }
      100% {
        transform: scale(0.8) rotate(180deg);
        opacity: 0;
        clip-path: polygon(50% 0, 100% 0, 100% 100%, 50% 100%);
      }
    }

    .breaking-left {
      animation: breakPiece 0.4s ease-out forwards;
      pointer-events: none;
      position: absolute;
      z-index: 1;
    }

    .breaking-right {
      animation: breakPieceRight 0.4s ease-out forwards;
      pointer-events: none;
      position: absolute;
      z-index: 1;
    }
  </style>
</head>
<body>
  <div class="chess-container">
    <h1>체스 보드 테스트 (Pointer Events)</h1>
    <div class="board-wrapper">
      <div id="chessBoard" class="chess-board">
        <!-- JS로 8x8 칸 생성 + 각 칸에 Pawn 하나씩 배치 -->
      </div>
    </div>
  </div>

  <script>
    const board = document.getElementById('chessBoard');
    let selectedPiece = null;   // 현재 선택된 기물
    let validMoves = [];        // 현재 선택된 기물의 유효한 이동 위치들
    let isWhiteTurn = true;     // 현재 턴 (true: 백, false: 흑)
    let lastMove = null;        // 마지막 이동 정보 (앙파상용)
    let canCastle = {           // 캐슬링 가능 여부
      white: { king: true, queen: true },
      black: { king: true, queen: true }
    };

    // 1) 8x8 칸 생성 + 각 칸에 Pawn 하나씩 배치
    for (let row = 8; row >= 1; row--) {
      for (let col = 1; col <= 8; col++) {
        const square = document.createElement('div');
        const isDark = (row + col) % 2 === 0;
        square.classList.add('square', isDark ? 'dark' : 'light');

        // 체스 초기 배치 구현
        if (row === 8 || row === 7 || row === 2 || row === 1) {  // 기물이 있는 줄만 처리
          const piece = document.createElement('div');
          piece.classList.add('piece');
          
          // 각 행별 기물 배치
          if (row === 8) {  // 첫 번째 줄 (흑)
            if (col === 1 || col === 8) {
              piece.classList.add('black', 'rook');
            } else if (col === 2 || col === 7) {
              piece.classList.add('black', 'knight');
            } else if (col === 3 || col === 6) {
              piece.classList.add('black', 'bishop');
            } else if (col === 4) {
              piece.classList.add('black', 'queen');
            } else if (col === 5) {
              piece.classList.add('black', 'king');
            }
          } else if (row === 7) {  // 두 번째 줄 (흑 폰)
            piece.classList.add('black', 'pawn');
          } else if (row === 2) {  // 일곱 번째 줄 (백 폰)
            piece.classList.add('white', 'pawn');
          } else if (row === 1) {  // 여덟 번째 줄 (백)
            if (col === 1 || col === 8) {
              piece.classList.add('white', 'rook');
            } else if (col === 2 || col === 7) {
              piece.classList.add('white', 'knight');
            } else if (col === 3 || col === 6) {
              piece.classList.add('white', 'bishop');
            } else if (col === 4) {
              piece.classList.add('white', 'queen');
            } else if (col === 5) {
              piece.classList.add('white', 'king');
            }
          }
          
          if (piece.classList.contains('black') || piece.classList.contains('white')) {
            square.appendChild(piece);
          }
        }

        board.appendChild(square);
      }
    }

    // 체스 보드 전체에 이벤트 위임
    board.addEventListener('pointerdown', onPointerDown);

    // 체스 좌표를 배열 인덱스로 변환 (예: a1 -> [7,0])
    function chessToArray(chessNotation) {
      const file = chessNotation.charCodeAt(0) - 'a'.charCodeAt(0);
      const rank = 8 - parseInt(chessNotation[1]);
      return [rank, file];
    }

    // 배열 인덱스를 체스 좌표로 변환 (예: [7,0] -> a1)
    function arrayToChess(rank, file) {
      const fileChar = String.fromCharCode('a'.charCodeAt(0) + file);
      const rankNum = 8 - rank;
      return `${fileChar}${rankNum}`;
    }

    // 주어진 위치에 있는 기물 가져오기
    function getPieceAt(rank, file) {
      const squares = board.children;
      const index = rank * 8 + file;
      const square = squares[index];
      return square.querySelector('.piece');
    }

    // 기물의 현재 위치 찾기
    function getPiecePosition(piece) {
      const square = piece.parentElement;
      const index = Array.from(board.children).indexOf(square);
      const rank = Math.floor(index / 8);
      const file = index % 8;
      return [rank, file];
    }

    // 이동 가능한 위치 계산
    function calculateValidMoves(piece) {
      const [currentRank, currentFile] = getPiecePosition(piece);
      const moves = [];
      const isWhite = piece.classList.contains('white');
      const pieceType = piece.classList.contains('king') ? 'king' :
                       piece.classList.contains('queen') ? 'queen' :
                       piece.classList.contains('rook') ? 'rook' :
                       piece.classList.contains('bishop') ? 'bishop' :
                       piece.classList.contains('knight') ? 'knight' :
                       'pawn';

      // 각 기물별 이동 규칙
      switch (pieceType) {
        case 'pawn':
          const direction = isWhite ? -1 : 1;
          const startRank = isWhite ? 6 : 1;
          const endRank = isWhite ? 0 : 7;

          // 전진
          if (currentRank + direction >= 0 && currentRank + direction < 8) {
            // 바로 앞칸이 비어있는 경우에만 전진 가능
            if (!getPieceAt(currentRank + direction, currentFile)) {
              moves.push([currentRank + direction, currentFile]);
              // 첫 이동시 2칸 전진
              if (currentRank === startRank && !getPieceAt(currentRank + 2 * direction, currentFile)) {
                moves.push([currentRank + 2 * direction, currentFile]);
              }
            }
          }

          // 대각선 공격
          for (const fileOffset of [-1, 1]) {
            const targetRank = currentRank + direction;
            const targetFile = currentFile + fileOffset;
            if (targetRank >= 0 && targetRank < 8 && targetFile >= 0 && targetFile < 8) {
              const targetPiece = getPieceAt(targetRank, targetFile);
              if (targetPiece && targetPiece.classList.contains(isWhite ? 'black' : 'white')) {
                moves.push([targetRank, targetFile]);
              }
            }
          }

          // 앙파상
          if (lastMove && lastMove.pieceType === 'pawn' && 
              Math.abs(lastMove.fromRank - lastMove.toRank) === 2 && 
              lastMove.toRank === currentRank && 
              Math.abs(lastMove.toFile - currentFile) === 1) {
            // 앙파상 가능
            moves.push([currentRank + direction, lastMove.toFile]);
          }
          break;

        case 'knight':
          const knightMoves = [
            [-2, -1], [-2, 1], [-1, -2], [-1, 2],
            [1, -2], [1, 2], [2, -1], [2, 1]
          ];
          for (const [rankOffset, fileOffset] of knightMoves) {
            const targetRank = currentRank + rankOffset;
            const targetFile = currentFile + fileOffset;
            if (targetRank >= 0 && targetRank < 8 && targetFile >= 0 && targetFile < 8) {
              const targetPiece = getPieceAt(targetRank, targetFile);
              if (!targetPiece || targetPiece.classList.contains(isWhite ? 'black' : 'white')) {
                moves.push([targetRank, targetFile]);
              }
            }
          }
          break;

        case 'bishop':
        case 'rook':
        case 'queen':
          const directions = [];
          if (pieceType === 'bishop' || pieceType === 'queen') {
            directions.push([-1, -1], [-1, 1], [1, -1], [1, 1]); // 대각선
          }
          if (pieceType === 'rook' || pieceType === 'queen') {
            directions.push([-1, 0], [1, 0], [0, -1], [0, 1]); // 직선
          }

          for (const [rankDir, fileDir] of directions) {
            let targetRank = currentRank + rankDir;
            let targetFile = currentFile + fileDir;
            while (targetRank >= 0 && targetRank < 8 && targetFile >= 0 && targetFile < 8) {
              const targetPiece = getPieceAt(targetRank, targetFile);
              if (!targetPiece) {
                moves.push([targetRank, targetFile]);
              } else {
                if (targetPiece.classList.contains(isWhite ? 'black' : 'white')) {
                  moves.push([targetRank, targetFile]);
                }
                break;
              }
              targetRank += rankDir;
              targetFile += fileDir;
            }
          }
          break;

        case 'king':
          const kingMoves = [
            [-1, -1], [-1, 0], [-1, 1],
            [0, -1], [0, 1],
            [1, -1], [1, 0], [1, 1]
          ];
          for (const [rankOffset, fileOffset] of kingMoves) {
            const targetRank = currentRank + rankOffset;
            const targetFile = currentFile + fileOffset;
            if (targetRank >= 0 && targetRank < 8 && targetFile >= 0 && targetFile < 8) {
              const targetPiece = getPieceAt(targetRank, targetFile);
              if (!targetPiece || targetPiece.classList.contains(isWhite ? 'black' : 'white')) {
                moves.push([targetRank, targetFile]);
              }
            }
          }

          // 캐슬링
          if (!isInCheck(isWhite)) {
            const color = isWhite ? 'white' : 'black';
            
            // 킹사이드 캐슬링
            if (canCastle[color].king && 
                !getPieceAt(currentRank, currentFile + 1) && 
                !getPieceAt(currentRank, currentFile + 2)) {
              const rook = getPieceAt(currentRank, 7);
              if (rook && rook.classList.contains(color) && rook.classList.contains('rook')) {
                moves.push([currentRank, currentFile + 2]);
              }
            }
            
            // 퀸사이드 캐슬링
            if (canCastle[color].queen && 
                !getPieceAt(currentRank, currentFile - 1) && 
                !getPieceAt(currentRank, currentFile - 2) && 
                !getPieceAt(currentRank, currentFile - 3)) {
              const rook = getPieceAt(currentRank, 0);
              if (rook && rook.classList.contains(color) && rook.classList.contains('rook')) {
                moves.push([currentRank, currentFile - 2]);
              }
            }
          }
          break;
      }

      // 체크 상태에서의 이동 제한: 킹을 체크 상태로 만드는 이동 제거
      return filterIllegalMoves(piece, moves);
    }

    // 체크 상태에서의 이동 제한: 킹을 체크 상태로 만드는 이동 제거
    function filterIllegalMoves(piece, moves) {
      const isWhite = piece.classList.contains('white');
      const filteredMoves = [];
      
      // 각 이동에 대해 시뮬레이션
      for (const [targetRank, targetFile] of moves) {
        // 현재 위치 가져오기
        const [currentRank, currentFile] = getPiecePosition(piece);
        
        // 이동 시뮬레이션
        const targetSquare = board.children[targetRank * 8 + targetFile];
        const capturedPiece = targetSquare.querySelector('.piece:not(.breaking-left):not(.breaking-right)');
        
        // 이동 시뮬레이션을 위한 임시 저장
        const originalParent = piece.parentElement;
        const originalNextSibling = piece.nextSibling;
        
        // 이동 시뮬레이션
        if (capturedPiece) {
          capturedPiece.style.display = 'none';
        }
        targetSquare.appendChild(piece);
        
        // 이동 후 체크 상태 확인
        const isInCheckAfterMove = isInCheck(isWhite);
        
        // 원래 상태로 복원
        if (originalNextSibling) {
          originalParent.insertBefore(piece, originalNextSibling);
        } else {
          originalParent.appendChild(piece);
        }
        
        if (capturedPiece) {
          capturedPiece.style.display = '';
        }
        
        // 체크 상태가 아니면 이동 가능
        if (!isInCheckAfterMove) {
          filteredMoves.push([targetRank, targetFile]);
        }
      }
      
      return filteredMoves;
    }

    // 체크 상태 확인
    function isInCheck(isWhite) {
      // 킹 위치 찾기
      let kingRank, kingFile;
      for (let rank = 0; rank < 8; rank++) {
        for (let file = 0; file < 8; file++) {
          const piece = getPieceAt(rank, file);
          if (piece && 
              piece.classList.contains(isWhite ? 'white' : 'black') && 
              piece.classList.contains('king')) {
            kingRank = rank;
            kingFile = file;
            break;
          }
        }
        if (kingRank !== undefined) break;
      }

      // 상대방 기물들의 이동 가능한 위치 확인
      for (let rank = 0; rank < 8; rank++) {
        for (let file = 0; file < 8; file++) {
          const piece = getPieceAt(rank, file);
          if (piece && piece.classList.contains(isWhite ? 'black' : 'white')) {
            const moves = calculateValidMovesWithoutCheck(piece);
            if (moves.some(([r, f]) => r === kingRank && f === kingFile)) {
              return true;
            }
          }
        }
      }
      return false;
    }

    // 체크 확인 없이 이동 가능한 위치 계산 (무한 재귀 방지)
    function calculateValidMovesWithoutCheck(piece) {
      const [currentRank, currentFile] = getPiecePosition(piece);
      const moves = [];
      const isWhite = piece.classList.contains('white');
      const pieceType = piece.classList.contains('king') ? 'king' :
                       piece.classList.contains('queen') ? 'queen' :
                       piece.classList.contains('rook') ? 'rook' :
                       piece.classList.contains('bishop') ? 'bishop' :
                       piece.classList.contains('knight') ? 'knight' :
                       'pawn';

      // 각 기물별 이동 규칙 (캐슬링 제외)
      switch (pieceType) {
        case 'pawn':
          const direction = isWhite ? -1 : 1;
          const startRank = isWhite ? 6 : 1;

          // 전진
          if (currentRank + direction >= 0 && currentRank + direction < 8) {
            if (!getPieceAt(currentRank + direction, currentFile)) {
              moves.push([currentRank + direction, currentFile]);
              if (currentRank === startRank && !getPieceAt(currentRank + 2 * direction, currentFile)) {
                moves.push([currentRank + 2 * direction, currentFile]);
              }
            }
          }

          // 대각선 공격
          for (const fileOffset of [-1, 1]) {
            const targetRank = currentRank + direction;
            const targetFile = currentFile + fileOffset;
            if (targetRank >= 0 && targetRank < 8 && targetFile >= 0 && targetFile < 8) {
              const targetPiece = getPieceAt(targetRank, targetFile);
              if (targetPiece && targetPiece.classList.contains(isWhite ? 'black' : 'white')) {
                moves.push([targetRank, targetFile]);
              }
            }
          }

          // 앙파상
          if (lastMove && lastMove.pieceType === 'pawn' && 
              Math.abs(lastMove.fromRank - lastMove.toRank) === 2 && 
              lastMove.toRank === currentRank && 
              Math.abs(lastMove.toFile - currentFile) === 1) {
            moves.push([currentRank + direction, lastMove.toFile]);
          }
          break;

        case 'knight':
          const knightMoves = [
            [-2, -1], [-2, 1], [-1, -2], [-1, 2],
            [1, -2], [1, 2], [2, -1], [2, 1]
          ];
          for (const [rankOffset, fileOffset] of knightMoves) {
            const targetRank = currentRank + rankOffset;
            const targetFile = currentFile + fileOffset;
            if (targetRank >= 0 && targetRank < 8 && targetFile >= 0 && targetFile < 8) {
              const targetPiece = getPieceAt(targetRank, targetFile);
              if (!targetPiece || targetPiece.classList.contains(isWhite ? 'black' : 'white')) {
                moves.push([targetRank, targetFile]);
              }
            }
          }
          break;

        case 'bishop':
        case 'rook':
        case 'queen':
          const directions = [];
          if (pieceType === 'bishop' || pieceType === 'queen') {
            directions.push([-1, -1], [-1, 1], [1, -1], [1, 1]); // 대각선
          }
          if (pieceType === 'rook' || pieceType === 'queen') {
            directions.push([-1, 0], [1, 0], [0, -1], [0, 1]); // 직선
          }

          for (const [rankDir, fileDir] of directions) {
            let targetRank = currentRank + rankDir;
            let targetFile = currentFile + fileDir;
            while (targetRank >= 0 && targetRank < 8 && targetFile >= 0 && targetFile < 8) {
              const targetPiece = getPieceAt(targetRank, targetFile);
              if (!targetPiece) {
                moves.push([targetRank, targetFile]);
              } else {
                if (targetPiece.classList.contains(isWhite ? 'black' : 'white')) {
                  moves.push([targetRank, targetFile]);
                }
                break;
              }
              targetRank += rankDir;
              targetFile += fileDir;
            }
          }
          break;

        case 'king':
          const kingMoves = [
            [-1, -1], [-1, 0], [-1, 1],
            [0, -1], [0, 1],
            [1, -1], [1, 0], [1, 1]
          ];
          for (const [rankOffset, fileOffset] of kingMoves) {
            const targetRank = currentRank + rankOffset;
            const targetFile = currentFile + fileOffset;
            if (targetRank >= 0 && targetRank < 8 && targetFile >= 0 && targetFile < 8) {
              const targetPiece = getPieceAt(targetRank, targetFile);
              if (!targetPiece || targetPiece.classList.contains(isWhite ? 'black' : 'white')) {
                moves.push([targetRank, targetFile]);
              }
            }
          }
          break;
      }

      return moves;
    }

    // 유효한 이동 위치 표시
    function showValidMoves(moves) {
      // 이전 표시 제거
      document.querySelectorAll('.valid-move').forEach(el => el.remove());
      
      moves.forEach(([rank, file]) => {
        const square = board.children[rank * 8 + file];
        const indicator = document.createElement('div');
        indicator.classList.add('valid-move');
        indicator.style.cssText = `
          position: absolute;
          width: 25%;
          height: 25%;
          background-color: rgba(0, 255, 0, 0.3);
          border-radius: 50%;
          pointer-events: none;
        `;
        square.appendChild(indicator);
      });
    }

    // 프로모션 다이얼로그 표시
    function showPromotionDialog(piece, callback) {
      const dialog = document.createElement('div');
      dialog.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        z-index: 1000;
        display: flex;
        gap: 10px;
      `;

      const isWhite = piece.classList.contains('white');
      const color = isWhite ? 'white' : 'black';
      const pieces = ['queen', 'rook', 'bishop', 'knight'];

      pieces.forEach(pieceType => {
        const option = document.createElement('div');
        option.style.cssText = `
          width: 60px;
          height: 60px;
          background-size: contain;
          background-repeat: no-repeat;
          background-position: center;
          cursor: pointer;
          border: 2px solid transparent;
          border-radius: 4px;
        `;
        
        option.style.backgroundImage = `url('./images/pieces/${color[0]}${pieceType[0]}.svg')`;
        
        option.addEventListener('mouseover', () => {
          option.style.borderColor = '#4CAF50';
        });
        
        option.addEventListener('mouseout', () => {
          option.style.borderColor = 'transparent';
        });
        
        option.addEventListener('click', () => {
          document.body.removeChild(dialog);
          callback(pieceType);
        });
        
        dialog.appendChild(option);
      });

      document.body.appendChild(dialog);
    }

    function onPointerDown(e) {
      const target = e.target;
      const targetSquare = target.closest('.square');

      if (!targetSquare) return;

      // 기물 선택 시 현재 턴의 기물만 선택 가능
      if (!selectedPiece && target.classList.contains('piece')) {
        const isWhitePiece = target.classList.contains('white');
        if (isWhitePiece !== isWhiteTurn) {
          return; // 현재 턴이 아닌 기물은 선택할 수 없음
        }
      }

      if (selectedPiece) {
        // 기물이 이미 선택된 상태
        const targetPiece = targetSquare.querySelector('.piece:not(.breaking-left):not(.breaking-right)');
        const targetIndex = Array.from(board.children).indexOf(targetSquare);
        const targetRank = Math.floor(targetIndex / 8);
        const targetFile = targetIndex % 8;
        
        // 현재 선택된 기물의 위치 가져오기
        const [currentRank, currentFile] = getPiecePosition(selectedPiece);
        
        // 이동이 유효한지 확인
        const isValidMove = validMoves.some(([rank, file]) => 
          rank === targetRank && file === targetFile
        );

        if (isValidMove) {
          // 이동하려는 칸에 상대방 기물이 있는지 명시적으로 확인
          const isOpponentPiece = targetPiece &&
                                   targetPiece !== selectedPiece &&
                                   targetPiece.classList.contains(isWhiteTurn ? 'black' : 'white');

          if (isOpponentPiece) {
            // 상대방 기물 제거 (잡기)
            const capturedPiece = targetPiece; // 잡힌 기물
            const leftPiece = capturedPiece.cloneNode(true);
            const rightPiece = capturedPiece.cloneNode(true);
            
            leftPiece.classList.add('breaking-left');
            rightPiece.classList.add('breaking-right');
            
            capturedPiece.style.display = 'none'; // 원본 기물 숨기기
            targetSquare.appendChild(leftPiece);
            targetSquare.appendChild(rightPiece);

            // 애니메이션이 끝난 후 복제된 조각들 제거
            leftPiece.addEventListener('animationend', () => {
              leftPiece.remove();
              rightPiece.remove();
              // 혹시 숨겨진 원본 기물이 남아있다면 제거 (안전장치)
              const hiddenOriginal = targetSquare.querySelector('.piece[style*="display: none"]');
              if (hiddenOriginal) hiddenOriginal.remove();
            }, { once: true }); // 이벤트 리스너 한번만 실행
          }
          
          // 캐슬링 처리
          const isKing = selectedPiece.classList.contains('king');
          const isCastling = isKing && Math.abs(targetFile - currentFile) === 2;
          
          if (isCastling) {
            // 킹사이드 캐슬링
            if (targetFile > currentFile) {
              const rookFile = 7;
              const rook = getPieceAt(targetRank, rookFile);
              if (rook) {
                const rookSquare = board.children[targetRank * 8 + (targetFile - 1)];
                rookSquare.appendChild(rook);
              }
            } 
            // 퀸사이드 캐슬링
            else {
              const rookFile = 0;
              const rook = getPieceAt(targetRank, rookFile);
              if (rook) {
                const rookSquare = board.children[targetRank * 8 + (targetFile + 1)];
                rookSquare.appendChild(rook);
              }
            }
            
            // 캐슬링 불가능으로 설정
            const color = isWhiteTurn ? 'white' : 'black';
            canCastle[color].king = false;
            canCastle[color].queen = false;
          }
          
          // 앙파상 처리
          const isPawn = selectedPiece.classList.contains('pawn');
          const isEnPassant = isPawn && 
                              lastMove && 
                              lastMove.pieceType === 'pawn' && 
                              Math.abs(lastMove.fromRank - lastMove.toRank) === 2 && 
                              lastMove.toRank === currentRank && 
                              Math.abs(lastMove.toFile - currentFile) === 1 && 
                              targetFile === lastMove.toFile;
          
          if (isEnPassant) {
            // 앙파상으로 잡은 폰 제거
            const capturedPawnSquare = board.children[lastMove.toRank * 8 + lastMove.toFile];
            const capturedPawn = capturedPawnSquare.querySelector('.piece');
            if (capturedPawn) {
              const leftPiece = capturedPawn.cloneNode(true);
              const rightPiece = capturedPawn.cloneNode(true);
              
              leftPiece.classList.add('breaking-left');
              rightPiece.classList.add('breaking-right');
              
              capturedPawn.style.display = 'none';
              capturedPawnSquare.appendChild(leftPiece);
              capturedPawnSquare.appendChild(rightPiece);
              
              leftPiece.addEventListener('animationend', () => {
                leftPiece.remove();
                rightPiece.remove();
                const hiddenOriginal = capturedPawnSquare.querySelector('.piece[style*="display: none"]');
                if (hiddenOriginal) hiddenOriginal.remove();
              }, { once: true });
            }
          }
          
          // 선택한 기물 이동
          targetSquare.appendChild(selectedPiece);
          
          // 프로모션 처리
          const isPromotion = isPawn && (targetRank === 0 || targetRank === 7);
          
          if (isPromotion) {
            // 프로모션 다이얼로그 표시
            showPromotionDialog(selectedPiece, (pieceType) => {
              // 기존 클래스 제거
              selectedPiece.classList.remove('pawn');
              // 새로운 클래스 추가
              selectedPiece.classList.add(pieceType);
              
              // 이동 완료 처리
              finishMove();
            });
          } else {
            // 일반 이동 완료 처리
            finishMove();
          }
          
          // 이동 완료 처리 함수
          function finishMove() {
            // 캐슬링 불가능 설정
            if (isKing) {
              const color = isWhiteTurn ? 'white' : 'black';
              canCastle[color].king = false;
              canCastle[color].queen = false;
            }
            
            // 룩 이동 시 캐슬링 불가능 설정
            if (selectedPiece.classList.contains('rook')) {
              const color = isWhiteTurn ? 'white' : 'black';
              if (currentFile === 0) {
                canCastle[color].queen = false;
              } else if (currentFile === 7) {
                canCastle[color].king = false;
              }
            }
            
            // 마지막 이동 정보 저장 (앙파상용)
            lastMove = {
              pieceType: selectedPiece.classList.contains('king') ? 'king' :
                        selectedPiece.classList.contains('queen') ? 'queen' :
                        selectedPiece.classList.contains('rook') ? 'rook' :
                        selectedPiece.classList.contains('bishop') ? 'bishop' :
                        selectedPiece.classList.contains('knight') ? 'knight' :
                        'pawn',
              fromRank: currentRank,
              fromFile: currentFile,
              toRank: targetRank,
              toFile: targetFile
            };
            
            selectedPiece.classList.remove('selected');
            document.querySelectorAll('.valid-move').forEach(el => el.remove());
            selectedPiece = null;
            validMoves = [];

            // 턴 변경
            isWhiteTurn = !isWhiteTurn;
            updateTurnIndicator();
          }
        } else if (target.classList.contains('piece')) {
          // 다른 기물 클릭: 선택 변경
          if (target === selectedPiece) {
            // 같은 기물 클릭: 선택 해제
            selectedPiece.classList.remove('selected');
            document.querySelectorAll('.valid-move').forEach(el => el.remove());
            selectedPiece = null;
            validMoves = [];
          } else {
            // 새로운 기물 선택 (현재 턴의 기물만 선택 가능)
            const isWhitePiece = target.classList.contains('white');
            if (isWhitePiece === isWhiteTurn) {
              selectedPiece.classList.remove('selected');
              document.querySelectorAll('.valid-move').forEach(el => el.remove());
              selectedPiece = target;
              selectedPiece.classList.add('selected');
              validMoves = calculateValidMoves(selectedPiece);
              showValidMoves(validMoves);
            }
          }
        }
      } else {
        // 선택된 기물이 없는 상태
        if (target.classList.contains('piece')) {
          // 기물 클릭: 선택
          selectedPiece = target;
          selectedPiece.classList.add('selected');
          validMoves = calculateValidMoves(selectedPiece);
          showValidMoves(validMoves);
        }
      }
    }

    // 턴 표시 업데이트
    function updateTurnIndicator() {
      const turnIndicator = document.getElementById('turnIndicator');
      if (!turnIndicator) {
        const indicator = document.createElement('div');
        indicator.id = 'turnIndicator';
        indicator.style.cssText = `
          text-align: center;
          font-size: 1.2em;
          margin: 10px 0;
          font-weight: bold;
        `;
        document.querySelector('.chess-container').insertBefore(
          indicator,
          document.querySelector('.board-wrapper')
        );
      }
      document.getElementById('turnIndicator').textContent = 
        `현재 턴: ${isWhiteTurn ? '백' : '흑'}`;
    }

    // 초기 턴 표시
    updateTurnIndicator();
  </script>
</body>
</html>