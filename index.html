<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Chess Board with Pointer Events</title>
  <style>
    /* ===== 전체 레이아웃 ===== */
    body {
      margin: 0;
      padding: 0;
      background-color: #fafafa;
      font-family: Arial, sans-serif;
    }
    .chess-container {
      max-width: 800px; 
      width: 100%;
      margin: 0 auto;
      padding: 20px;
      box-sizing: border-box;
      background-color: #ffffff;
      min-height: 100vh;
    }
    .board-wrapper {
      width: 100%;
      max-width: 480px;
      margin: 0 auto;
    }

    /* ===== 체스 보드 (8x8) ===== */
    .chess-board {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      grid-template-rows: repeat(8, 1fr);
      border: 2px solid #333;
      aspect-ratio: 1 / 1; /* 가로/세로 비율 1:1 */
    }
    .square {
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative; /* 기물이 상대배치(absolute)로 들어올 수 있음 */
    }
    .dark {
      background-color: #769656;
    }
    .light {
      background-color: #eeeed2;
    }

    /* ===== 기물 스타일 ===== */
    .piece {
      width: 90%;
      height: 90%;
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      position: relative;
      z-index: 1;
      margin: auto;
    }
    /* 각 기물별 배경 위치 */
    .piece.black.king { background-image: url('./images/pieces/bk.svg'); }
    .piece.black.queen { background-image: url('./images/pieces/bq.svg'); }
    .piece.black.rook { background-image: url('./images/pieces/br.svg'); }
    .piece.black.bishop { background-image: url('./images/pieces/bb.svg'); }
    .piece.black.knight { background-image: url('./images/pieces/bn.svg'); }
    .piece.black.pawn { background-image: url('./images/pieces/bp.svg'); }
    .piece.white.king { background-image: url('./images/pieces/wk.svg'); }
    .piece.white.queen { background-image: url('./images/pieces/wq.svg'); }
    .piece.white.rook { background-image: url('./images/pieces/wr.svg'); }
    .piece.white.bishop { background-image: url('./images/pieces/wb.svg'); }
    .piece.white.knight { background-image: url('./images/pieces/wn.svg'); }
    .piece.white.pawn { background-image: url('./images/pieces/wp.svg'); }
    /* 드래그 중 상태를 표시할 수도 있음 */
    .dragging {
      opacity: 0.8;
      cursor: grabbing;
    }
    /* 선택된 기물 표시 */
    .selected {
      outline: 3px solid rgba(255, 255, 0, 0.7); /* 노란색 테두리 */
      outline-offset: -3px; /* 테두리를 안쪽으로 */
    }
  </style>
</head>
<body>
  <div class="chess-container">
    <h1>체스 보드 테스트 (Pointer Events)</h1>
    <div class="board-wrapper">
      <div id="chessBoard" class="chess-board">
        <!-- JS로 8x8 칸 생성 + 각 칸에 Pawn 하나씩 배치 -->
      </div>
    </div>
  </div>

  <script>
    const board = document.getElementById('chessBoard');

    // 1) 8x8 칸 생성 + 각 칸에 폰(♙) 하나씩 배치
    for (let row = 8; row >= 1; row--) {
      for (let col = 1; col <= 8; col++) {
        const square = document.createElement('div');
        const isDark = (row + col) % 2 === 0;
        square.classList.add('square', isDark ? 'dark' : 'light');

        // 체스 초기 배치 구현
        if (row === 8 || row === 7 || row === 2 || row === 1) {  // 기물이 있는 줄만 처리
          const piece = document.createElement('div');
          piece.classList.add('piece');
          
          // 각 행별 기물 배치
          if (row === 8) {  // 첫 번째 줄 (흑)
            if (col === 1 || col === 8) {
              piece.classList.add('black', 'rook');
            } else if (col === 2 || col === 7) {
              piece.classList.add('black', 'knight');
            } else if (col === 3 || col === 6) {
              piece.classList.add('black', 'bishop');
            } else if (col === 4) {
              piece.classList.add('black', 'queen');
            } else if (col === 5) {
              piece.classList.add('black', 'king');
            }
          } else if (row === 7) {  // 두 번째 줄 (흑 폰)
            piece.classList.add('black', 'pawn');
          } else if (row === 2) {  // 일곱 번째 줄 (백 폰)
            piece.classList.add('white', 'pawn');
          } else if (row === 1) {  // 여덟 번째 줄 (백)
            if (col === 1 || col === 8) {
              piece.classList.add('white', 'rook');
            } else if (col === 2 || col === 7) {
              piece.classList.add('white', 'knight');
            } else if (col === 3 || col === 6) {
              piece.classList.add('white', 'bishop');
            } else if (col === 4) {
              piece.classList.add('white', 'queen');
            } else if (col === 5) {
              piece.classList.add('white', 'king');
            }
          }
          
          if (piece.classList.contains('black') || piece.classList.contains('white')) {
            square.appendChild(piece);
          }
        }

        board.appendChild(square);
      }
    }

    let selectedPiece = null;   // 현재 선택된 기물
    let validMoves = [];        // 현재 선택된 기물의 유효한 이동 위치들

    // 체스 보드 전체에 이벤트 위임
    board.addEventListener('pointerdown', onPointerDown);

    // 체스 좌표를 배열 인덱스로 변환 (예: a1 -> [7,0])
    function chessToArray(chessNotation) {
      const file = chessNotation.charCodeAt(0) - 'a'.charCodeAt(0);
      const rank = 8 - parseInt(chessNotation[1]);
      return [rank, file];
    }

    // 배열 인덱스를 체스 좌표로 변환 (예: [7,0] -> a1)
    function arrayToChess(rank, file) {
      const fileChar = String.fromCharCode('a'.charCodeAt(0) + file);
      const rankNum = 8 - rank;
      return `${fileChar}${rankNum}`;
    }

    // 주어진 위치에 있는 기물 가져오기
    function getPieceAt(rank, file) {
      const squares = board.children;
      const index = rank * 8 + file;
      const square = squares[index];
      return square.querySelector('.piece');
    }

    // 기물의 현재 위치 찾기
    function getPiecePosition(piece) {
      const square = piece.parentElement;
      const index = Array.from(board.children).indexOf(square);
      const rank = Math.floor(index / 8);
      const file = index % 8;
      return [rank, file];
    }

    // 이동 가능한 위치 계산
    function calculateValidMoves(piece) {
      const [currentRank, currentFile] = getPiecePosition(piece);
      const moves = [];
      const isWhite = piece.classList.contains('white');
      const pieceType = piece.classList.contains('king') ? 'king' :
                       piece.classList.contains('queen') ? 'queen' :
                       piece.classList.contains('rook') ? 'rook' :
                       piece.classList.contains('bishop') ? 'bishop' :
                       piece.classList.contains('knight') ? 'knight' :
                       'pawn';

      // 각 기물별 이동 규칙
      switch (pieceType) {
        case 'pawn':
          const direction = isWhite ? -1 : 1;
          const startRank = isWhite ? 6 : 1;

          // 전진
          if (currentRank + direction >= 0 && currentRank + direction < 8) {
            // 바로 앞칸이 비어있는 경우에만 전진 가능
            if (!getPieceAt(currentRank + direction, currentFile)) {
              moves.push([currentRank + direction, currentFile]);
              // 첫 이동시 2칸 전진
              if (currentRank === startRank && !getPieceAt(currentRank + 2 * direction, currentFile)) {
                moves.push([currentRank + 2 * direction, currentFile]);
              }
            }
          }

          // 대각선 공격
          for (const fileOffset of [-1, 1]) {
            const targetRank = currentRank + direction;
            const targetFile = currentFile + fileOffset;
            if (targetRank >= 0 && targetRank < 8 && targetFile >= 0 && targetFile < 8) {
              const targetPiece = getPieceAt(targetRank, targetFile);
              if (targetPiece && targetPiece.classList.contains(isWhite ? 'black' : 'white')) {
                moves.push([targetRank, targetFile]);
              }
            }
          }
          break;

        case 'knight':
          const knightMoves = [
            [-2, -1], [-2, 1], [-1, -2], [-1, 2],
            [1, -2], [1, 2], [2, -1], [2, 1]
          ];
          for (const [rankOffset, fileOffset] of knightMoves) {
            const targetRank = currentRank + rankOffset;
            const targetFile = currentFile + fileOffset;
            if (targetRank >= 0 && targetRank < 8 && targetFile >= 0 && targetFile < 8) {
              const targetPiece = getPieceAt(targetRank, targetFile);
              if (!targetPiece || targetPiece.classList.contains(isWhite ? 'black' : 'white')) {
                moves.push([targetRank, targetFile]);
              }
            }
          }
          break;

        case 'bishop':
        case 'rook':
        case 'queen':
          const directions = [];
          if (pieceType === 'bishop' || pieceType === 'queen') {
            directions.push([-1, -1], [-1, 1], [1, -1], [1, 1]); // 대각선
          }
          if (pieceType === 'rook' || pieceType === 'queen') {
            directions.push([-1, 0], [1, 0], [0, -1], [0, 1]); // 직선
          }

          for (const [rankDir, fileDir] of directions) {
            let targetRank = currentRank + rankDir;
            let targetFile = currentFile + fileDir;
            while (targetRank >= 0 && targetRank < 8 && targetFile >= 0 && targetFile < 8) {
              const targetPiece = getPieceAt(targetRank, targetFile);
              if (!targetPiece) {
                moves.push([targetRank, targetFile]);
              } else {
                if (targetPiece.classList.contains(isWhite ? 'black' : 'white')) {
                  moves.push([targetRank, targetFile]);
                }
                break;
              }
              targetRank += rankDir;
              targetFile += fileDir;
            }
          }
          break;

        case 'king':
          const kingMoves = [
            [-1, -1], [-1, 0], [-1, 1],
            [0, -1], [0, 1],
            [1, -1], [1, 0], [1, 1]
          ];
          for (const [rankOffset, fileOffset] of kingMoves) {
            const targetRank = currentRank + rankOffset;
            const targetFile = currentFile + fileOffset;
            if (targetRank >= 0 && targetRank < 8 && targetFile >= 0 && targetFile < 8) {
              const targetPiece = getPieceAt(targetRank, targetFile);
              if (!targetPiece || targetPiece.classList.contains(isWhite ? 'black' : 'white')) {
                moves.push([targetRank, targetFile]);
              }
            }
          }
          break;
      }

      return moves;
    }

    // 유효한 이동 위치 표시
    function showValidMoves(moves) {
      // 이전 표시 제거
      document.querySelectorAll('.valid-move').forEach(el => el.remove());
      
      moves.forEach(([rank, file]) => {
        const square = board.children[rank * 8 + file];
        const indicator = document.createElement('div');
        indicator.classList.add('valid-move');
        indicator.style.cssText = `
          position: absolute;
          width: 25%;
          height: 25%;
          background-color: rgba(0, 255, 0, 0.3);
          border-radius: 50%;
          pointer-events: none;
        `;
        square.appendChild(indicator);
      });
    }

    function onPointerDown(e) {
      const target = e.target;
      const targetSquare = target.closest('.square');

      if (!targetSquare) return;

      if (selectedPiece) {
        // 기물이 이미 선택된 상태
        const targetPiece = targetSquare.querySelector('.piece');
        const targetIndex = Array.from(board.children).indexOf(targetSquare);
        const targetRank = Math.floor(targetIndex / 8);
        const targetFile = targetIndex % 8;
        
        // 이동이 유효한지 확인
        const isValidMove = validMoves.some(([rank, file]) => 
          rank === targetRank && file === targetFile
        );

        if (isValidMove) {
          // 이동하려는 칸에 상대방 기물이 있는지 확인
          if (targetPiece && targetPiece !== selectedPiece) {
            // 상대방 기물 제거 (잡기)
            targetPiece.remove();
          }
          
          targetSquare.appendChild(selectedPiece);
          selectedPiece.classList.remove('selected');
          document.querySelectorAll('.valid-move').forEach(el => el.remove());
          selectedPiece = null;
          validMoves = [];
        } else if (target.classList.contains('piece')) {
          // 다른 기물 클릭: 선택 변경
          if (target === selectedPiece) {
            // 같은 기물 클릭: 선택 해제
            selectedPiece.classList.remove('selected');
            document.querySelectorAll('.valid-move').forEach(el => el.remove());
            selectedPiece = null;
            validMoves = [];
          } else {
            // 새로운 기물 선택
            selectedPiece.classList.remove('selected');
            document.querySelectorAll('.valid-move').forEach(el => el.remove());
            selectedPiece = target;
            selectedPiece.classList.add('selected');
            validMoves = calculateValidMoves(selectedPiece);
            showValidMoves(validMoves);
          }
        }
      } else {
        // 선택된 기물이 없는 상태
        if (target.classList.contains('piece')) {
          // 기물 클릭: 선택
          selectedPiece = target;
          selectedPiece.classList.add('selected');
          validMoves = calculateValidMoves(selectedPiece);
          showValidMoves(validMoves);
        }
      }
    }
  </script>
</body>
</html>
